# amoCrmFront1
script.js   testovaya zadacha 4
===================================================
Техническое задание
Нагуглить
Бизнес-задача
Пользователи часто закрывают сделки с описанием «нет связи». Для того, чтобы уменьшить количество нереализованных сделок можно найти дополнительную информацию о клиенте и его контакты в интернете. 
Сейчас при клике на номер телефона или почту открываются меню с выбором, например позвонить, написать из amoCRM и т.д.
При клике на номер телефона или почту добавить в этот выпадающий список кнопку «Нагуглить» (иконку можно вставить лупу с поиска). При нажатии на неё в открываются 2 вкладки http://letmegooglethat.com/?q=viktor%40intr.bz, где вместо запроса  ?q=viktor%40intr.bz соответственно вставляется телефон или почта, на которые кликали, и  https://yandex.ru/search/?text=viktor@intr.bz,  где вместо запроса ?text=viktor@intr.bz соответственно вставляется телефон или почта, на которые кликали.

Это позволит ускорить процесс получения информации о почте или телефоне клиента для сотрудника.

Техническое описание
Back end
Нет.

Front-end
Работа виджета
======================================================


 index.js   testovaya zadacha3
======================================================
Виджеты
Виджет в платформе Yadro — класс на js, который реализует бизнес-логику и основные событийные методы.
Все виджеты подключаются на аккаунт клиента в amoCRM с помощью специального загрузчика loader.php, который вызывается из amoCRM при загрузке страницы.
Шаблон виджета
// widgetNameIntr - уникальное имя вашего виджета, должно коррелировать с его назначением

widgetNameIntr = function() {
    var widget = this;
    this.code = null;

    this.yourVar = {};
    this.yourFunc = function() {};

    // вызывается один раз при инициализации виджета, в этой функции мы вешаем события на $(document)
    this.bind_actions = function(){
        //пример $(document).on('click', 'selector', function(){});
    };

    // вызывается каждый раз при переходе на страницу
    this.render = function() {
		
    };

    // вызывается один раз при инициализации виджета, в этой функции мы загружаем нужные данные, стили и.т.п
    this.init = function(){

    };

    // метод загрузчик, не изменяется
    this.bootstrap = function(code) {
        widget.code = code;
        // если frontend_status не задан, то считаем что виджет выключен
        // var status = yadroFunctions.getSettings(code).frontend_status;
        var status = 1;

        if (status) {
            widget.init();
            widget.render();
            widget.bind_actions();
            $(document).on('widgets:load', function () {
                widget.render();
            });
        }
    }
};
// создание экземпляра виджета и регистрация в системных переменных Yadra
// widget-name - ИД и widgetNameIntr - уникальные названия виджета
yadroWidget.widgets['widget-name'] = new widgetNameIntr();
yadroWidget.widgets['widget-name'].bootstrap('widget-name');

Файл виджета

Файл виджета должен быть с расширением .php. По необходимости он может содержать php-код получения дополнительных настроек и генерации js-кода.

Тестовый режим
При разработке виджета он подключается к аккаунту в тестовом режиме. Это означает, что он не будет по умолчанию включен в исполняемый код, который формируется загрузчиком loader.php.
Для включения виджета, работающего в тестовом режиме, в загрузчик необходимо в консоли браузера выполнить следующий код:

// подключение виджета, работающего в тестовом режиме. id - ИД виджета
test_yadro_start(id);

После этого необходимо перезагрузить страницу. Далее виджет будет всегда подключен.
АРХИВ
Не актуальная информация

Концепция

Виджет вызывает загрузчик, который компонует нужные виджеты-модули для загрузки для конкретного клиента.

Виджет-модуль - это отдельный виджет (например, виджет запрета редактирования задач), который подключается в загрузчике. Такие виджеты реализуют прикладную логику для клиента. Виджет-модуль - это js-скрипт, который может формироваться на php. По необходимости он может конфигурироваться настройками из системы Yadro. Расширение файла должно быть .php

Для реализации общей логики в amoCRM любой виджет-модуль может использовать общие js-функции:
1. Создавать модальные окна
2. Добавлять виджет в правую часть виджетов
3. Получать значение доп. поля по его ИД
4. Открывать страницу контакта, сделки
5. Получать значение cookie

Исходник js-файла:http://introvert.bz/yadrotrue/_widget/_tmp/func.js

Всё необходимое управление каждым виджетом-модулем реализуется в системе Yadro.

По необходимости виджет может отправлять/получать данные, запрашивая свои прикладные php-скрипты. Все виджеты-модули компонуются и загружаются один раз при загрузке страницы. Далее при переходе по ссылкам, меню, сделкам виджет больше не формируется и используется кэш в браузере. Для обновления содержимого виджета нужно сделать обычное обновление страницы (F5)

Уже написаны десятки виджетов, поэтому запрашивайте примеры, чтобы ускорить разработку. Список уже готовых виджетов будет вскоре доступен.


Последовательность разработки виджета

Запросите у Михаила Абрамова пример виджета, похожий на ваш. Возможно уже многое готово.


Создайте свой php-скрипт, который будет генерировать весь js-код для виджета. Файл скрипта всегда размещайте в отдельной подпапке, сам файл скрипта удобно называть просто widget.php. Отправьте Михаилу Абрамову следующие данные:
- название виджета
- ссылку на скрипт
- имя клиента и его ИД в платформе Yadro, для которого делается разработка.
Скрипт будет зарегистрирован в платформе Yadro.

Например:
-виджет запрета редактирования задач
-http://domain.ru/tasks-noeditable/widget.php
-клиент Клиент1, номер clid в ядре = 1

Любой скрипт модуля, как правило, реализует обработку одного или нескольких событий. Список доступных событий:
window.myWidget.render - запускается при открытии любой страницы
window.myWidget.init - запускается один раз при обновлении страницы
window.myWidget.bind_actions - используется для навешивания событий на действия предпринимаемые пользователем, например нажатие пользователя на кнопку
window.myWidget.settings
window.myWidget.onSave
window.myWidget.destroy
window.myWidget.contacts
window.myWidget.leads
window.myWidget.tasks

Пример простейшего виджета-модуля:
window.myWidget.render.push(function(self){
  // код
  alert('i am introvert');
  return true;
});

Все виджеты должны заканчиваться строчкой return true;
Если необходимо, чтобы виджет отработавал только на карточке сделок, то нужно вручную проверку:

window.myWidget.render.push(function(self){
  // код
  if(AMOCRM.data.current_entity == 'leads'){
    alert('i am introvert');
  }
  return true;
});

Теперь необходимо виджет-модуль зарегистрировать, чтобы всё хорошо протестировать. Пришлите информацию о клиенте (для какого аккаунта в amoCRM делается виджет), ссылку и название виджета Абрамову Михаилу для регистрации виджета в системе.


Теперь ваш скрипт будет вызываться всякий раз, когда сотрудники загружают amoCRM. Скрипт будет вызывать с ключом key - API-ключ платформы Yadro. Также доп. параметрами будут передаваться все параметры, которые доступны.
Параметры $_REQUEST будут добавлены в POST параметр request.
Информация о пользователе, который использует скрипт, будет добавлена в POST-параметр user.

В ответ скрипт должен отдать js-код, который будет загружен в amoCRM. Старайтесь сделать свой скрипт универсальным, чтобы он работал и для других проектов.

При необходимости js-код может содержать любые вызовы на другие скрипты для получения других данных. Или отправлять данные на обработку.
Например, формируется js-код, содержащий форму. При заполнении формы идет отправка данных формы на другой php-скрипт, который отправляет данные в другую систему.

Всю разработку хорошо оттестируйте на тестовом аккаунте amoCRM, только после этого запускайте на боевом аккаунте клиента.

По любым вопросам реализации виджета держите связь с Михаилом Абрамовым
обавлены в POST параметр request.
Информация о пользовател

Информация о виджетах в amoCRM

1. Используя подход разработки виджетов, описанный в этом документе, документация к виджетам в amoCRM становится не до конца актуальной. Часть, относящаяся к регистрации виджета, загрузки, работа с файлом манифеста - всё это делается единым виджетом платформы Yadro. Тем не менее эту документацию полезно изучить, т.к. “тело” виджета остается неизменным.

2. В исходниках виджета часто идет работа с объектом AMOCRM - это объект самого приложения amoCRM, официальной документации на него нет.
Остается напрямую изучать объект в консоли браузера: console.log(AMOCRM);

3. Для календаря в селектах(date picker) amoCRM использует https://github.com/ChiperSoft/Kalendae , можно смотреть документацию от него.
Для календаря в задачах http://fullcalendar.io/
В качестве каркаса приложения используется backbone, например роутинг AMOCRM.router. Т.ч. можно полистать документацию от него.

4. Вопрос: как отловить событие по открытию задачи в меню Задачи -> Список
Чтобы при открытии задачии отловить это событие и внести изменение в форму редактирования задачи.

Ответ: важно изучить систему событий amoCRM

На скриншотах выше есть стандартные js-события типа click, submit и т.д. и есть кастомные, которые вызывает amoCRM через $(element).trigger('custom:event:name'); при наступлении определенных событий. Какие из них для чего бывает сложно понять, нужно смотреть код, но в основном понятно из названия, например "add:button:save" вызывается когда происходит нажатие на кнопку сохранить. 
Эти события можно отлавливать как и стандартные $(document).on('add:button:save', function() {});

Нужного события может и не быть (как в этом случае), тогда необходимо отслеживать появление формы:
$(document).on('click', '.list-todo .js-pager-list-item__1', function(e) {
 	var timerId = setTimeout(function tick() {
var form = $('#modal_add_task_form');

if (form.length) {
console.log('form');
} else {
console.log('no form');
timerId = setTimeout(tick, 10);
}
}, 10);
});

Здесь сделано через setTimeout(), он вызывается один раз, и если форма найдена, то выводим console.log('form'), а если форма не найдена, то ставим еще один setTimeout(). Т.е. если форма будет найдена то автоматом прекратит вызываться, а вот если не найдена, то будет вызываться пока не найдет форму.

Что делать если виджет-модуль работает в одних случаях, и не работает в других случаях
Все виджеты модули загружаются одним большим кодом. Может получится так, что один виджет написан с ошибками, и он может блокировать работу другого виджета.
Если есть такая ситуация, что виджет работает например в сделке, но не работает в списке сделок, то это явный признак такой ситуации. В этом случае стоит отключить все другие виджеты и проверить будет ли работать один виджет-модуль. Если будет, то подключать по одному другие и так найти виджет, который дает сбои.


Работа с визуальными элементами в amoCRM

Очень часто необходимо добавить новый визуальный элемент в amoCRM.
Например: сделать своё меню, или добавить новый виджет в меню справа, или добавить галочку, кнопку и т.д.

В таких случаях разработчик обязательно должен весь дизайн сделать в стиле amoCRM. 
Для решения таких задач необходимо использовать встроенные в amoCRM шаблоны.
И только если их нет, необходимо изучать верстку amoCRM и копировать её - это делается в крайнем случае, если нет в списке ниже шаблона для этого и не удалось найти шаблон самостоятельно. Если в списке ниже нет шаблона, но его удалось найти самостоятельно, нужно добавить найденный шаблон в этот файл.

Как найти шаблон самостоятельно
Все шаблоны, используемые amoCRM, можно найти, прописав в консоли: Twig.Templates.registry



Пример:
Нужно сверстать input с выпадающим списком (как на форме при добавлении/редактировании задачи):



Посмотрим на класс обертки этого элемента:



Ищем что-то похожее в списке шаблонов:
Открываем, переходим во вкладку tokens и видим структуру этого шаблона:

Структура шаблона примерно совпадает с кодом этого элемента, следовательно, мы нашли нужный нам шаблон.
Теперь нужно понять какие параметры нужно передать. Для этого нужно подробно ознакомится со структурой шаблона.
У каждого объекта в структуре шаблона есть тип raw, logic или output.

Если объект имеет тип raw, это значит что значение (value) будет напечатано.
В нашем примере: 

Если объект имеет тип output, это значит что будет напечатан наш параметр.
В нашем примере:

в этом случае у объекта есть stack, и у stack-а есть value, которое хранит в себе название параметра(т.е. если мы передаем параметр {class_name:’test class’}, то будет напечатано ‘test_class’).

Если объект имеет тип logic значит объект содержит логическую функцию (например if, else, elseif, for и.т.п) а так же внутри объекта есть другие tokens, которые появляются если выполняется логическая функция.

в конечном итоге код выглядит вот так:
var twig = require('twigjs');
var managers_array = [];
//заполняем массив объектами которые будут элементами выпадающего списка
$.each(AMOCRM.constant('account').users, function(user_id, name) {
        	managers_array.push({
            	id: user_id,
            	option: name
        	});
});
manager_select = twig({ref: '/tmpl/controls/select.twig'}).render({
        	name: 'manager_select', //имя нашего шаблона
        	selected: user_id, //id выбранного 
        	items:managers_array, //элементы выпадающего списка
        	id: 'manager_select_input', //id input-а
        	class_name: ‘’//имя класса
});

Список шаблонов
1. Добавление контекстного меню (по аналогии как на кнопке Ещё):
var twig = require('twigjs');
var context_menu_item;
context_menu_item.push({
class_name:'contextMenuItemClass',  //класс элемента контекстного меню
	id: 'contextMenuItemId',   		 //id элемента контекстного меню
    	text: 'contextMenuItemText'   		 //тескст элемента контекстного меню
});
button = twig({ref: '/tmpl/controls/button.twig'}).render({
class_name: 'buttonWrapperClassName',
    	text : 'buttonText',
    	id : 'buttonId',
type : 'buttonType',
    	additional_data : 'additionalData', //доп инф-я
    	tab_index: '123',
	inner_class_name: 'buttonInnerClassName',   		 
    	context_menu: context_menu_item, /*массив элементов контекстного меню, если он отсутсвует то будет обычная кнопка*/
    	context_menu_class_name: 'contextMenuClassName',    //класс ul списка
});



2. Выбор даты (по аналогии как при добавлении/редактировании задачи)
date_select = twig({ref: '/tmpl/common/tasks_date.twig'}).render({
date: '05.08.2016 10:00', //установленная дата, по умолчанию:“Сегодня”
	class_name: 'dateSelectClassName'    //класс элемента
});

3. Простой input text
name_input = twig({ref: '/tmpl/controls/input.twig'}).render({
    name: 'inputName',
    placeholder: 'inputPlaceholder',
    id: 'inputId',
    value: 'inputValue',
    class_name: 'inputClassName'
});

4. Визуальный элемент Мультисписка
var twig = require('twigjs');
items = [];

items.push({
  option: 'inputValue1',
  id: 'inputId1',
  name: 'inputName1',
  is_checked:'true'
});
items.push({
  option: 'inputValue2',
  id: 'inputId2',
  name: 'inputName2',
});

multiselect = twig({
  ref: '/tmpl/controls/checkboxes_dropdown.twig'
}).render({
  title_before: 'titleBefore',
  title_numeral: 'значение, значения',
  title_empty: 'Название при пустом выборе',
  items: items
});


      
